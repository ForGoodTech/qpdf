<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>qpdf wasm demo</title>
</head>
<body>
  <input type="file" id="file" accept="application/pdf" />
  <select id="level">
    <option value="fast">Fast</option>
    <option value="balanced" selected>Balanced</option>
    <option value="smallest">Smallest</option>
  </select>
  <button id="run">Compress</button>
  <script src="qpdf-wasm.js"></script>
  <script>
    let ready = false;
    let qpdf;

    Module().then((mod) => {
      qpdf = mod;
      if (qpdf.FS && qpdf.FS.filesystems && qpdf.FS.filesystems.OPFS) {
        qpdf.FS.mkdir('/opfs');
        qpdf.FS.mount(qpdf.FS.filesystems.OPFS, { root: '.' }, '/opfs');
      }
      ready = true;
    });

    function compress(input, output, level) {
      console.log('compress()', { input, output, level });
      const encoder = new TextEncoder();
      const inBuf = encoder.encode(input + '\0');
      const inPtr = qpdf._malloc(inBuf.length);
      qpdf.HEAPU8.set(inBuf, inPtr);
      const outBuf = encoder.encode(output + '\0');
      const outPtr = qpdf._malloc(outBuf.length);
      qpdf.HEAPU8.set(outBuf, outPtr);
      const lvlBuf = encoder.encode(level + '\0');
      const lvlPtr = qpdf._malloc(lvlBuf.length);
      qpdf.HEAPU8.set(lvlBuf, lvlPtr);
      const rc = qpdf._qpdf_wasm_compress(inPtr, outPtr, lvlPtr);
      console.log('qpdf_wasm_compress returned', rc);
      if (rc !== 0) {
        console.error('Compression failed');
      }
      qpdf._free(inPtr);
      qpdf._free(outPtr);
      qpdf._free(lvlPtr);
    }

    document.getElementById('run').addEventListener('click', async () => {
      try {
        if (!ready) {
          alert('WASM not initialized yet');
          return;
        }
        const fi = document.getElementById('file');
        if (!fi.files.length) {
          alert('Select a PDF first');
          return;
        }
        const file = fi.files[0];
        if (qpdf.FS && qpdf.FS.filesystems?.OPFS && navigator.storage?.getDirectory) {
          console.log('Using OPFS');
          const root = await navigator.storage.getDirectory();
          const inputHandle = await root.getFileHandle('input.pdf', { create: true });
          const writable = await inputHandle.createWritable();
          await file.stream().pipeTo(writable);
          const input = '/opfs/input.pdf';
          const output = '/opfs/output.pdf';
          const level = document.getElementById('level').value;
          compress(input, output, level);
          const outHandle = await root.getFileHandle('output.pdf');
          const outFile = await outHandle.getFile();
          const url = URL.createObjectURL(outFile);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'compressed.pdf';
          a.click();
          URL.revokeObjectURL(url);
          await root.removeEntry('input.pdf');
          await root.removeEntry('output.pdf');
        } else {
          console.log('Using in-memory FS');
          const buf = new Uint8Array(await file.arrayBuffer());
          qpdf.FS.writeFile('input.pdf', buf);
          const level = document.getElementById('level').value;
          compress('input.pdf', 'output.pdf', level);
          const out = qpdf.FS.readFile('output.pdf');
          const blob = new Blob([out], { type: 'application/pdf' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'compressed.pdf';
          a.click();
          URL.revokeObjectURL(url);
          qpdf.FS.unlink('input.pdf');
          qpdf.FS.unlink('output.pdf');
        }
      } catch (e) {
        console.error('Error in compression handler', e);
      }
    });
  </script>
</body>
</html>
