<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>qpdf wasm demo</title>
  <style>
    #progress {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: conic-gradient(#e6e6e6 0%, #e6e6e6 100%);
    }
  </style>
</head>
<body>
  <input type="file" id="file" accept="application/pdf" />
  <label>JPEG quality:
    <input type="number" id="jpeg" min="60" max="75" value="75" />
  </label>
  <button id="run">Compress</button>
  <div id="progress"></div>
  <script src="qpdf-wasm.js"></script>
  <script>
    let ready = false;
    let qpdf;
    Module().then((mod) => {
      qpdf = mod;
      if (qpdf.FS && qpdf.FS.filesystems && qpdf.FS.filesystems.OPFS) {
        qpdf.FS.mkdir('/opfs');
        qpdf.FS.mount(qpdf.FS.filesystems.OPFS, { root: '.' }, '/opfs');
      }
      ready = true;
    });

    function compress(input, output, level, jpeg) {
      const encoder = new TextEncoder();
      const inBuf = encoder.encode(input + '\0');
      const inPtr = qpdf._malloc(inBuf.length);
      qpdf.HEAPU8.set(inBuf, inPtr);
      const outBuf = encoder.encode(output + '\0');
      const outPtr = qpdf._malloc(outBuf.length);
      qpdf.HEAPU8.set(outBuf, outPtr);
      const ratePtr = qpdf._malloc(8);
      qpdf._qpdf_wasm_compress(inPtr, outPtr, level, jpeg, ratePtr);
      const rate = qpdf.HEAPF64[ratePtr >> 3];
      const progress = qpdf._qpdf_wasm_get_progress();
      qpdf._free(inPtr);
      qpdf._free(outPtr);
      qpdf._free(ratePtr);
      return { rate, progress };
    }

    document.getElementById('run').addEventListener('click', async () => {
      if (!ready) {
        alert('WASM not initialized yet');
        return;
      }
      const fi = document.getElementById('file');
      if (!fi.files.length) {
        alert('Select a PDF first');
        return;
      }
      const jpeg = parseInt(document.getElementById('jpeg').value) || 75;
      const progressEl = document.getElementById('progress');
      progressEl.style.background = 'conic-gradient(#e6e6e6 0%, #e6e6e6 100%)';
      const file = fi.files[0];
      const levels = [3, 6, 9];
      const outputs = ['l3.pdf', 'l6.pdf', 'l9.pdf'];
      const ratios = [];
      if (qpdf.FS && qpdf.FS.filesystems?.OPFS && navigator.storage?.getDirectory) {
        const root = await navigator.storage.getDirectory();
        const inputHandle = await root.getFileHandle('input.pdf', { create: true });
        const writable = await inputHandle.createWritable();
        await file.stream().pipeTo(writable);
        const input = '/opfs/input.pdf';
        let best = { rate: 0, idx: -1 };
        let progress = 0;
        for (let i = 0; i < levels.length; ++i) {
          const r = compress(input, `/opfs/${outputs[i]}`, levels[i], jpeg);
          ratios.push(r.rate);
          if (r.rate > best.rate) best = { rate: r.rate, idx: i };
          progress = r.progress;
        }
        console.log('ratios', ratios);
        progressEl.style.background = `conic-gradient(#4d90fe ${progress}%, #e6e6e6 0)`;
        if (best.rate <= 0) {
          alert('File is already compact');
        } else {
          const outHandle = await root.getFileHandle(outputs[best.idx]);
          const outFile = await outHandle.getFile();
          const url = URL.createObjectURL(outFile);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'compressed.pdf';
          a.click();
          URL.revokeObjectURL(url);
          alert(`Saved ${Math.round(best.rate * 100)}%`);
        }
        await root.removeEntry('input.pdf');
        for (const o of outputs) {
          try { await root.removeEntry(o); } catch (e) {}
        }
      } else {
        const buf = new Uint8Array(await file.arrayBuffer());
        qpdf.FS.writeFile('input.pdf', buf);
        let best = { rate: 0, idx: -1 };
        let progress = 0;
        for (let i = 0; i < levels.length; ++i) {
          const r = compress('input.pdf', outputs[i], levels[i], jpeg);
          ratios.push(r.rate);
          if (r.rate > best.rate) best = { rate: r.rate, idx: i };
          progress = r.progress;
        }
        console.log('ratios', ratios);
        progressEl.style.background = `conic-gradient(#4d90fe ${progress}%, #e6e6e6 0)`;
        if (best.rate <= 0) {
          alert('File is already compact');
        } else {
          const out = qpdf.FS.readFile(outputs[best.idx]);
          const blob = new Blob([out], { type: 'application/pdf' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'compressed.pdf';
          a.click();
          URL.revokeObjectURL(url);
          alert(`Saved ${Math.round(best.rate * 100)}%`);
        }
        qpdf.FS.unlink('input.pdf');
        for (const o of outputs) {
          try { qpdf.FS.unlink(o); } catch (e) {}
        }
      }
    });
  </script>
</body>
</html>

